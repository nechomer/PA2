package ic.parser;

import ic.*;
import ic.parser.*;
import ic.ast.*;
import ic.ast.expr.*;
import ic.ast.methods.*;
import ic.ast.stmt.*;
import ic.ast.types.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
class ProgramParser;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	
	public boolean printTokens;
	
	private Lexer lexer;
	private int currentLine = 0;

	public LibraryParser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return currentLine;
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + tok);
	}

	private void makeFieldsOfType(List<Field> fieldsList, Type t)
	{
		for (Field f: fieldsList) {
			f.setType(t);
		}
	}
:}

// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	currentLine = t.getLine();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t);
	return t; 
:};

/*********** Symbol list - terminals ***********/
terminal CLASS, EXTENDS, STATIC;
terminal VOID, INTEGER, BOOLEAN, STRING;
terminal RETURN, IF, ELSE, WHILE, BREAK, CONTINUE;
terminal THIS, NEW, LENGTH;
terminal LBRACKET, RBRACKET; /****array_type****/
terminal LPAREN, RPAREN;
terminal DOT, MINUS, NOT, MULT, DIV, MODULU, PLUS, LT, LTEQ, GT, GTEQ, EQEQ, NEQ, AND, OR, EQ;
terminal LBRACE, RBRACE, SEMI, COMA;


terminal java.lang.String IDENTIFIER; /****var_name****/
terminal java.lang.String CLASS_ID; /****class_name****/
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Boolean TRUE_LITERAL;
terminal java.lang.Boolean FALSE_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal NULL_LITERAL;

/*********** Symbol list - non-terminals) ***********/

non terminal Program program;
non terminal ICClass icclass;
non terminal List<ICClass> icclass_list;
non terminal String class_extends;
non terminal FieldsAndMethodsList class_body;

non terminal Method method;
non terminal List<Field> field_list;
non terminal java.lang.String field;

non terminal StaticMethod static_method;
non terminal VirtualMethod virtual_method;


non terminal List<Statement> stmt_list;
non terminal Statement stmt;
non terminal StatementsBlock stmt_block;

non terminal Assignment assignment_stmt;
non terminal CallStatement call_stmt;
non terminal Return return_stmt;
non terminal If if_stmt;
non terminal If if_else_stmt;
non terminal While while_stmt;
non terminal Break break_stmt;
non terminal Continue continue_stmt;


non terminal StaticCall static_call;
non terminal VirtualCall virtual_call;

non terminal CallParams call_without_exprs;
non terminal CallParams call_with_exprs;
non terminal CallParams call_with_expr;
non terminal CallParams call_without_expr;
non terminal java.lang.String dot_identifier;

non terminal List<Formal> formal_list;
non terminal Formal formal;
non terminal Type type;

non terminal Expression expr;
non terminal List<Expression> expr_list;
non terminal Location location;
non terminal Call call_expr;
non terminal Expression binop_expr;
non terminal Expression unop_expr;
non terminal Literal literal;

/*********** Precedence declarations ***********/

precedence left  ELSE;
precedence right EQ;
precedence left  OR;
precedence left  AND;
precedence left  EQEQ, NEQ;
precedence left  LT, LTEQ, GT, GTEQ;
precedence left  MINUS, PLUS;
precedence left  DIV, MULT, MODULU;
precedence right NOT;
precedence left  LPAREN, LBRACKET, DOT;

/*********** The grammar ***********/

program ::= icclass_list:iccl

	{: RESULT = new Program(iccl); :}

	| 		{: RESULT = new Program(new ArrayList<ICClass>()); :}

	;
icclass_list ::=  icclass:icc

	{: List<ICClass> classList = new ArrayList<ICClass>(); classList.add(icc); RESULT = classList; :}

	|		icclass_list:iccl icclass:icc

	{: iccl.add(icc); RESULT = iccl; :}

	;

icclass ::= CLASS CLASS_ID:ci class_extends:ce LBRACE class_body:cb RBRACE

	{: 
		if (ce == null) {		/* there is no extention to the class */
		RESULT = new ICClass(getLine(), ci, cb.getFields(), cb.getMethods()); 
		} else {
		RESULT = new ICClass(getLine(), ci, ce,cb.getFields(), cb.getMethods()); 
		}
	:}

	;

class_extends ::= 	EXTENDS CLASS_ID:ci

		{: RESULT = ci; :}

	| 	{: RESULT = null; :}			/* return null as String */

	;

class_body ::= 	class_body:cb field_list:fl SEMI

		{: cb.insertFields(fl); RESULT = cb; :}

	|			class_body:cb method:m

		{: cb.insertMethod(m); RESULT = cb; :}

	| 	{: RESULT = new FieldsAndMethodsList(); :}

	;

method ::= 	static_method:sm
		
		{: RESULT = sm; :}

	|		virtual_method:vm

		{: RESULT = vm; :}

	;


/* very complex, relys on formals.... */
field_list ::= 	formal:f

		{: List<Field> fieldsList = new ArrayList<Field>(); 
			makeFieldsOfType(fieldsList, f.getType()); 
			Field field = new Field(f.getType(), f.getName()); 
			fieldsList.add(field);
			RESULT = new List<Field> 
		:}

	| 			field_list:fl COMA field:f

		{: fl.add(new Field(new PrimitiveType(1, DataTypes.INT), f)); RESULT = fl; :}

	;

field ::= IDENTIFIER:id

		{: RESULT = id; :}

	;

static_method ::= STATIC type:t IDENTIFIER:id LPAREN RPAREN LBRACKET stmt_list:sl RBRACKET

		{: RESULT = new StaticMethod(t, id, new ArrayList<Formal>(), sl); :}

	|	STATIC type:t IDENTIFIER:id LPAREN formal_list:fl RPAREN LBRACKET stmt_list:sl RBRACKET

		{: RESULT = new StaticMethod(t, id, fl, sl); :}

	|	STATIC VOID IDENTIFIER:id LPAREN RPAREN LBRACKET stmt_list:sl RBRACKET

		{: RESULT = new StaticMethod(new PrimitiveType(getLine(), DataTypes.VOID), id, new ArrayList<Formal>(), sl); :}

	|	STATIC VOID IDENTIFIER:id LPAREN formal_list:fl RPAREN LBRACKET stmt_list:sl RBRACKET

		{: RESULT = new StaticMethod(new PrimitiveType(getLine(), DataTypes.VOID) , id, fl, sl); :}

	;

virtual_method ::=  type:t IDENTIFIER:id LPAREN RPAREN LBRACKET stmt_list:sl RBRACKET
		
		{: RESULT = new VirtualMethod(t, id, new ArrayList<Formal>(), sl); :}

	| 	 type:t IDENTIFIER:id LPAREN formal_list:fl RPAREN LBRACKET stmt_list:sl RBRACKET

		{: RESULT = new VirtualMethod(t, id, fl, sl); :}

	|	 VOID IDENTIFIER:id LPAREN RPAREN LBRACKET stmt_list:sl RBRACKET

		{: RESULT = new VirtualMethod(new PrimitiveType(getLine(), DataTypes.VOID), id, new ArrayList<Formal>(), sl); :}

	|	 VOID IDENTIFIER:id LPAREN formal_list:fl RPAREN LBRACKET stmt_list:sl RBRACKET

		{: RESULT = new VirtualMethod(new PrimitiveType(getLine(), DataTypes.VOID) , id, fl, sl); :}

	;


stmt_list ::=		stmt_list:sl stmt:st

		{: sl.add(st); RESULT = sl; :}

	| 		{: RESULT = new ArrayList<Statement>(); :}		/* return empty List<Statement> */

	;

stmt ::= 	assignment_stmt:as SEMI

		{: RESULT = as; :}

	|		call_stmt:cs

		{: RESULT = cs; :}

	|		return_stmt:rs SEMI

		{: RESULT = rs; :}

	|		if_stmt:is SEMI

		{: RESULT = is; :}

	|		if_else_stmt:ies

		{: RESULT = ies; :}

	|		while_stmt:ws

		{: RESULT = ws; :}

	|		break_stmt:bs SEMI

		{: RESULT = bs; :}

	|		continue_stmt:cs SEMI

		{: RESULT = cs; :}

	|		stmt_block:sb

		{: RESULT = sb; :}

	|		type:t IDENTIFIER:i SEMI

		{: RESULT = new LocalVariable(t, i); :} 

	|		type:t IDENTIFIER:i EQ expr:e SEMI

		{: RESULT = new LocalVariable(t, i, e); :}

	;

assignment_stmt ::= location:l EQ expr:e

		{: RESULT = new Assignment(l, e); :}

	;

call_stmt ::= 	call_expr:ce SEMI

		{: RESULT =  new CallStatement(ce); :}

	;

return_stmt ::= RETURN

		{: RESULT = new Return(getLine()); :}

	|			RETURN expr:e

		{: RESULT = new Return(getLine(), e); :}

	;

if_stmt ::= IF LPAREN expr:e RPAREN stmt:s

		{: RESULT = new If(e, s); :}

	;

if_else_stmt ::= IF LPAREN expr:e RPAREN stmt:s1 ELSE stmt:s2

		{: RESULT = new If(e, s1, s2); :}

	;

while_stmt ::= WHILE LPAREN expr:e RPAREN stmt:s

		{: RESULT = new While(e, s); :}

	;

break_stmt ::= BREAK

		{: RESULT = new Break(getLine()); :}

	;

continue_stmt ::= CONTINUE

		{: RESULT = new Continue(getLine()); :}

	;

stmt_block ::=	LBRACKET stmt_list:sl RBRACKET

		{: RESULT = new StatementsBlock(getLine(), sl); :}

	;

expr ::= location:l

		{: RESULT = l; :}

	|	call_expr:c

		{: RESULT = c; :}

	|	THIS

		{: RESULT = new This(getLine()); :}

	|	NEW CLASS_ID:ci LPAREN RPAREN

		{: RESULT = new NewClass(getLine(), ci); :}

	|	NEW type:t LBRACKET expr:e RBRACKET

		{: RESULT = new NewArray(t, e); :}

	|	expr:e DOT LENGTH

		{: RESULT = new Length(e); :}

	|	binop_expr:e

		{: RESULT = e; :}

	|	unop_expr:e

		{: RESULT = e; :}

	|	literal:l

		{: RESULT = l; :}

	|	LPAREN expr:e RPAREN

		{: RESULT = new ExpressionBlock(e); :}

	;

call_expr ::= 	static_call:sc

		{: RESULT = sc; :}

	|			virtual_call:vc

		{: RESULT = vc; :}

	;

expr_list ::= expr:e

		{: List<Expression> expsList = new ArrayList<Expression>(); expsList.add(e); RESULT = expsList; :}

	|	expr_list:el COMA expr:e

		{: el.add(e); RESULT = el; :}

	;

formal_list ::= formal:f

		{: List<Formal> formalList = new ArrayList<Formal>(); formalList.add(f); RESULT = formalList; :}

	| 			formal_list:fl COMA formal:f

		{: fl.add(f); RESULT = fl; :}

	;

formal  ::= type:t IDENTIFIER:i

		{: RESULT = new Formal(t, i); :}

	;

type  ::= 		INTEGER

	{: RESULT = new PrimitiveType(getLine(), DataTypes.INT); System.out.println("added primitive integer"); :}

		|		BOOLEAN

	{: RESULT = new PrimitiveType(getLine(), DataTypes.BOOLEAN); System.out.println("added primitive boolean");:}

		|		STRING

	{: RESULT = new PrimitiveType(getLine(), DataTypes.STRING); System.out.println("added primitive string");:}

		|		CLASS_ID:ci

	{: RESULT = new UserType(getLine(), ci); System.out.println("added TYPE User Defined type");:}

		| 		type:ft LBRACKET RBRACKET

	{: ft.incrementDimension(); RESULT = ft; System.out.println("added array ft=" + ft);:} 

	;

static_call ::= CLASS_ID:ci call_without_expr:cwe

		{: RESULT = StaticCall(getLine(), ci, cwe.getMethodName(), cwe.getArguments()) :}

	;
		
virtual_call ::= call_with_expr:cwe

		{: RESULT = VirtualCall(cwe.getLine(), cwe.getLocation(), cwe.getMethodName(), cwe.getArguments()) :}

	| call_without_expr

		{: RESULT = VirtualCall(cwe.getLine(), cwe.getMethodName(), cwe.getArguments()) :}

	;

call_with_expr ::= expr:e call_without_expr:cwe	

		{: cwe.stLine(getLine()); cwe.setLocation(e); RESULT = cwe; :}

	;

call_without_expr::= call_without_exprs:cwe

		{: RESULT = cwe; :}

	|	    dot_identifier:id call_with_exprs:cwe

		{: cwe.setClassName(id); RESULT = cwe; :}


	;

call_without_exprs ::= dot_identifier:id LPAREN RPAREN

		{: CallParams cp = new CallParams(); cp.setClassName(id); cp.setArguments(new ArrayList<Expression>()); RESULT = cp; :}

	;
		
call_with_exprs ::= LPAREN expr_list:el RPAREN

		{: CallParams cp = new CallParams(); cp.setArguments(el); RESULT = cp; :}

	;

dot_identifier ::= DOT IDENTIFIER:id

		{: RESULT = id; :}

	;

location ::=	IDENTIFIER:id

		{: RESULT = new VariableLocation(getLine(), id); :}

	|		expr:e dot_identifier:id

		{: RESULT = new VariableLocation(getLine(), e, id); :}

	|		expr:e1 LBRACE expr:e2 RBRACE

		{: RESULT = new ArrayLocation(e1, e2); :}

	;


binop_expr	::=	expr:e1 PLUS expr:e2

	{: RESULT = new BinaryOp(e1, BinaryOps.PLUS, e2); :}
		
	|			expr:e1 MINUS expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.MINUS, e2); :}
		
	|	    	expr:e1 MULT expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.MULTIPLY, e2); :}
		
	|			expr:e1 DIV expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.DIVIDE, e2); :}
		
	|	    	expr:e1 MODULU expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.MOD, e2); :}
		
	|			expr:e1 AND expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.LAND, e2); :}
		
	|			expr:e1 OR expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.LOR, e2); :}
		
	|			expr:e1 LT expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.LT, e2); :}
		
	|			expr:e1 LTEQ expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.LTE, e2); :}
		
	|			expr:e1 GT expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.GT, e2); :}
		
	|			expr:e1 GTEQ expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.GTE, e2); :}
		
	|			expr:e1 EQEQ expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.EQUAL, e2); :}
		
	|			expr:e1 NEQ expr:e2
	
	{: RESULT = new BinaryOp(e1, BinaryOps.NEQUAL, e2); :}	
	
	;	
		
unop_expr	::=	NOT expr:e

	{: RESULT = new UnnaryOp(UnaryOps.LNEG, e); :}
		
	|			MINUS expr:e
	
	{: RESULT = new UnnaryOp(UnaryOps.UMINUS, e); :}
		
	;
		

literal ::=	    STRING_LITERAL:st

		{: RESULT = new Literal(getLine(), LiteralTypes.STRING, st); :}

	|		INTEGER_LITERAL:integr

		{: RESULT = new Literal(getLine(), LiteralTypes.INTEGER, integr); :}

	|		TRUE_LITERAL

		{: RESULT = new Literal(getLine(), LiteralTypes.TRUE); :}

	|		FALSE_LITERAL

		{: RESULT = new Literal(getLine(), LiteralTypes.FALSE); :}

	|		NULL_LITERAL

		{: RESULT = new Literal(getLine(), LiteralTypes.NULL); :}

	;


package ic.parser;

import ic.*;
import ic.parser.*;
import ic.ast.*;
import ic.ast.expr.*;
import ic.ast.methods.*;
import ic.ast.stmt.*;
import ic.ast.types.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
class LibraryParser;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	
	public boolean printTokens;
	
	private Lexer lexer;
	private int currentLine = 0;

	public LibraryParser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return currentLine;
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + tok);
	}
:}

// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	currentLine = t.getLine();
	if (printTokens)
		System.out.println(t.getLine() + ":" + t);
	return t; 
:};

/*********** Symbol list - terminals ***********/
terminal CLASS, EXTENDS, STATIC;
terminal VOID, INTEGER, BOOLEAN, STRING;
terminal RETURN, IF, ELSE, WHILE, BREAK, CONTINUE;
terminal THIS, NEW, LENGTH;
terminal LBRACKET, RBRACKET; /****array_type****/
terminal LPAREN, RPAREN;
terminal DOT, MINUS, NOT, MULT, DIV, MODULU, PLUS, LT, LTEQ, GT, GTEQ, EQEQ, NEQ, AND, OR, EQ;
terminal LBRACE, RBRACE,SEMI, COMA;


terminal java.lang.String IDENTIFIER; /****var_name****/
terminal java.lang.String CLASS_ID; /****class_name****/
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal NULL_LITERAL;


/*********** Symbol list - non-terminals) ***********/

non treminal stmt, stmt_open, stmt_closed, stmt_simple  
non terminal 

non terminal Program program;
non terminal ICClass icclass;
non terminal List<ICClass> icclass_block;
non terminal String class_extends;
non terminal List<ASTNode> class_body;

non terminal Method method;
non terminal List<Field> field_list;
non terminal Field field;

non terminal StaticMethod static_method;
non terminal VirtualMethod virtual_method;


non terminal List<Statement> stmt_list;
non terminal Statement stmt;
non terminal StatementsBlock stmt_block;

non terminal Assignment assignment_stmt;
non terminal CallStatement call_stmt;
non terminal Return return_stmt;
non terminal If if_stmt;
non terminal While while_stmt;
non terminal Break break_stmt;
non terminal Continue continue_stmt;


non terminal List<Formal> formal_list;
non terminal Formal formal;
non terminal Type methodType;
non terminal Type type;

non terminal StaticCall staticCall;
non terminal VirtualCall virtualCall;
non terminal Expression expr;
non terminal Location location;
non terminal Call call;
non terminal This this;
non terminal New new;
non terminal BinaryOp binop;
non terminal UnaryOp unop;
non terminal Literal literal;

/*********** Precedence declarations ***********/


/*********** The grammar ***********/

program ::= icclass:icc
	|		icclass_block:iccb icclass:icc
	| 		/* return new program with empty List<ICClass> */
	;

icclass ::= CLASS CLASS_ID:ci class_extends:ce LBRACE class_body:cb RBRACE
	;

class_extends ::= 	EXTENDS CLASS_ID:ci
	| 				/* return null as String */
	;

class_body ::= 	class_body:cb field_list:fl SEMI		/* return new List<ASTNode> after cb
															list unified with field list */
	|			class_body:cb method:m SEMI
	|			field_list:fl SEMI						/* return new List<ASTNode> with 1 object */
	|			method:m SEMI						/* return new List<ASTNode> with 1 object */
	| 				/* return empty List<ASTNode> */
	;

method ::= 	static_method
	|		virtual_method
	;

field_list ::= 	field:f
	| 			field_list:fl COMA field:f
	;

field ::= type:t IDENTIFIER:i
	{: RESULT = new Field(t,i); System.out.println("added field t= "+t+" : i= "+i); :}
	;

static_method ::= STATIC methodType:t IDENTIFIER:id LPAREN formal_list:fl RPAREN LBRACKET stmt_list RBRACKET
	;

virtual_method ::= 	methodType:t IDENTIFIER:id LPAREN formal_list:fl RPAREN LBRACKET stmt_list RBRACKET
	;


stmt_list ::= 	stmt:st 
	|			stmt_list:sl stmt:st
	| 				/* return empty List<Statement> */
	;

stmt ::= assignment_stmt SEMI
	|	call_stmt SEMI
	|	return_stmt SEMI
	|	if_stmt SEMI
	|	while_stmt SEMI
	|	break_stmt SEMI
	|	continue_stmt SEMI
	|	stmt_block
	|	type Identifier:i
	|	type Identifier:i EQ expr





method_block ::= stmethod:sm 
	{: List<Method> mb = new ArrayList<Method>(); mb.add(sm); RESULT = mb; System.out.println("crate function block with methods mb= "+mb+" added function sm = "+sm);:}
	| 			 method_block:mb SEMI stmethod:sm   
	{: mb.add(sm); RESULT = mb; System.out.println("added function to function block with methods mb= "+mb+" added function sm = "+sm); :}
	| 			 
	{: List<Method> mb = new ArrayList<Method>(); RESULT = mb; :}
	;

stmethod ::= STATIC methodType:t IDENTIFIER:id LPAREN formal_list:fl RPAREN 
	{:RESULT = new StaticMethod(t,id,fb,null); System.out.println("finish function "+id+" : "+fb); :}
	;


		




formal_list ::= formal:f
	| 			formal_list:fl COMA formal:f
	| 			/* return empty List<Formal> */
	;

formal  ::= primitive_type:t IDENTIFIER:i
	{: RESULT = new Formal(t,i); System.out.println("added formal t= "+t+" : i= "+i); :}
	;

methodType ::=	type:ft
	{: RESULT = ft; :}
	|			VOID
	{: RESULT = new PrimitiveType(getLine(), DataTypes.VOID); System.out.println("type void"); :}
	;

type  ::= 		INTEGER
	{: RESULT = new PrimitiveType(getLine(), DataTypes.INT); System.out.println("added primitive integer"); :}
		|		BOOLEAN
	{: RESULT = new PrimitiveType(getLine(), DataTypes.BOOLEAN); System.out.println("added primitive boolean");:}
		|		STRING
	{: RESULT = new PrimitiveType(getLine(), DataTypes.STRING); System.out.println("added primitive string");:}
		|		CLASS_ID:ci
	{: RESULT = new UserType(getLine(), ci); System.out.println("added TYPE User Defined type");:}
		| 		type:ft LBRACKET RBRACKET
	{: ft.incrementDimension(); RESULT = ft; System.out.println("added array ft=" + ft);:} 
	;

exprStar ::=   COMA expr:e 
		|	   COMA expr:e exprStar
		|	   NULL:nullPtr
		;

staticCall ::= CLASS_ID:ci DOT IDENTIFIER:id LPAREN RPAREN 
		|	   CLASS_ID:ci DOT IDENTIFIER:id LPAREN  expr:e exprStar:eStar RPAREN 	
		;
		
virtualCall ::= DOT IDENTIFIER:id LPAREN RPAREN 
		|	    DOT IDENTIFIER:id LPAREN expr:e exprStar:eStar RPAREN
		|		Expr:e DOT IDENTIFIER:id LPAREN RPAREN 
		|	    Expr:e DOT IDENTIFIER:id LPAREN expr:e exprStar:eStar RPAREN 	 	
		;
		
location ::=	IDENTIFIER:id
		|		expr:e DOT IDENTIFIER:id
		|		expr:e LBRACE expr:e RBRACE
		;
		
binop	::= 	DOT:bop
		|		MINUS:bop
		|		NOT:bop
		|	    MULT:bop
		|		DIV:bop
		|	    MODULU:bop
		|		PLUS:bop
		|		LT:bop
		|		LTEQ:bop
		|		GT:bop
		|		GTEQ:bop
		|		EQEQ:bop
		|		NEQ:bop
		|		AND:bop
		|		OR:bop
		|		EQ:bop
		;
		
		
unop	::=		UMINUS:uop
		|		LNEG:uop
		;
		
literal ::=	    STRING:st
		|		INTEGER:int
		|		BOOLEAN:bool
		|		NULL:nullPtr
		;
